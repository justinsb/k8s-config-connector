// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1beta1

// +kcc:proto=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy
type AlertPolicy_AlertStrategy_NotificationChannelStrategy struct {
	// The full REST resource name for the notification channels that these
	//  settings apply to. Each of these correspond to the name field in one
	//  of the NotificationChannel objects referenced in the
	//  notification_channels field of this AlertPolicy.
	//  The format is:
	//
	//      projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy.notification_channel_names
	NotificationChannelNames []string `json:"notificationChannelNames,omitempty"`

	// The frequency at which to send reminder notifications for open
	//  incidents.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy.renotify_interval
	RenotifyInterval *string `json:"renotifyInterval,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit
type AlertPolicy_AlertStrategy_NotificationRateLimit struct {
	// Not more than one notification per `period`.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit.period
	Period *string `json:"period,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.LogMatch
type AlertPolicy_Condition_LogMatch struct {
	// Required. A logs-based filter. See [Advanced Logs
	//  Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
	//  for how this filter should be constructed.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.LogMatch.filter
	Filter *string `json:"filter,omitempty"`

	// Optional. A map from a label key to an extractor expression, which is
	//  used to extract the value for this label key. Each entry in this map is
	//  a specification for how data should be extracted from log entries that
	//  match `filter`. Each combination of extracted values is treated as a
	//  separate rule for the purposes of triggering notifications. Label keys
	//  and corresponding values can be used in notifications generated by this
	//  condition.
	//
	//  Please see [the documentation on logs-based metric
	//  `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
	//  for syntax and examples.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.LogMatch.label_extractors
	LabelExtractors map[string]string `json:"labelExtractors,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence
type AlertPolicy_Condition_MetricAbsence struct {
	// Required. A
	//  [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies which time series should be compared with the threshold.
	//
	//  The filter is similar to the one that is specified in the
	//  [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
	//  (that call is useful to verify the time series that will be retrieved /
	//  processed). The filter must specify the metric type and the resource
	//  type. Optionally, it can specify resource labels and metric labels.
	//  This field must not exceed 2048 Unicode characters in length.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence.filter
	Filter *string `json:"filter,omitempty"`

	// Specifies the alignment of data points in individual time series as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources). Multiple aggregations
	//  are applied in the order specified.
	//
	//  This field is similar to the one in the [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
	//  It is advisable to use the `ListTimeSeries` method when debugging this
	//  field.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence.aggregations
	Aggregations []Aggregation `json:"aggregations,omitempty"`

	// The amount of time that a time series must fail to report new
	//  data to be considered failing. The minimum value of this field
	//  is 120 seconds. Larger values that are a multiple of a
	//  minute--for example, 240 or 300 seconds--are supported.
	//  If an invalid value is given, an
	//  error will be returned. The `Duration.nanos` field is
	//  ignored.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence.duration
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence.trigger
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold
type AlertPolicy_Condition_MetricThreshold struct {
	// Required. A
	//  [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies which time series should be compared with the threshold.
	//
	//  The filter is similar to the one that is specified in the
	//  [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
	//  (that call is useful to verify the time series that will be retrieved /
	//  processed). The filter must specify the metric type and the resource
	//  type. Optionally, it can specify resource labels and metric labels.
	//  This field must not exceed 2048 Unicode characters in length.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.filter
	Filter *string `json:"filter,omitempty"`

	// Specifies the alignment of data points in individual time series as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources). Multiple aggregations
	//  are applied in the order specified.
	//
	//  This field is similar to the one in the [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
	//  It is advisable to use the `ListTimeSeries` method when debugging this
	//  field.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.aggregations
	Aggregations []Aggregation `json:"aggregations,omitempty"`

	// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies a time series that should be used as the denominator of a
	//  ratio that will be compared with the threshold. If a
	//  `denominator_filter` is specified, the time series specified by the
	//  `filter` field will be used as the numerator.
	//
	//  The filter must specify the metric type and optionally may contain
	//  restrictions on resource type, resource labels, and metric labels.
	//  This field may not exceed 2048 Unicode characters in length.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.denominator_filter
	DenominatorFilter *string `json:"denominatorFilter,omitempty"`

	// Specifies the alignment of data points in individual time series
	//  selected by `denominatorFilter` as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources).
	//
	//  When computing ratios, the `aggregations` and
	//  `denominator_aggregations` fields must use the same alignment period
	//  and produce time series that have the same periodicity and labels.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.denominator_aggregations
	DenominatorAggregations []Aggregation `json:"denominatorAggregations,omitempty"`

	// When this field is present, the `MetricThreshold` condition forecasts
	//  whether the time series is predicted to violate the threshold within
	//  the `forecast_horizon`. When this field is not set, the
	//  `MetricThreshold` tests the current value of the timeseries against the
	//  threshold.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.forecast_options
	ForecastOptions *AlertPolicy_Condition_MetricThreshold_ForecastOptions `json:"forecastOptions,omitempty"`

	// The comparison to apply between the time series (indicated by `filter`
	//  and `aggregation`) and the threshold (indicated by `threshold_value`).
	//  The comparison is applied on each time series, with the time series
	//  on the left-hand side and the threshold on the right-hand side.
	//
	//  Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.comparison
	Comparison *string `json:"comparison,omitempty"`

	// A value against which to compare the time series.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.threshold_value
	ThresholdValue *float64 `json:"thresholdValue,omitempty"`

	// The amount of time that a time series must violate the
	//  threshold to be considered failing. Currently, only values
	//  that are a multiple of a minute--e.g., 0, 60, 120, or 300
	//  seconds--are supported. If an invalid value is given, an
	//  error will be returned. When choosing a duration, it is useful to
	//  keep in mind the frequency of the underlying time series data
	//  (which may also be affected by any alignments specified in the
	//  `aggregations` field); a good duration is long enough so that a single
	//  outlier does not generate spurious alerts, but short enough that
	//  unhealthy states are detected and alerted on quickly.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.duration
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`,
	//  or by the ratio, if `denominator_filter` and `denominator_aggregations`
	//  are specified.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.trigger
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`

	// A condition control that determines how metric-threshold conditions
	//  are evaluated when data stops arriving. To use this control, the value
	//  of the `duration` field must be greater than or equal to 60 seconds.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.evaluation_missing_data
	EvaluationMissingData *string `json:"evaluationMissingData,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions
type AlertPolicy_Condition_MetricThreshold_ForecastOptions struct {
	// Required. The length of time into the future to forecast whether a
	//  time series will violate the threshold. If the predicted value is
	//  found to violate the threshold, and the violation is observed in all
	//  forecasts made for the configured `duration`, then the time series is
	//  considered to be failing.
	//  The forecast horizon can range from 1 hour to 60 hours.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions.forecast_horizon
	ForecastHorizon *string `json:"forecastHorizon,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition
type AlertPolicy_Condition_MonitoringQueryLanguageCondition struct {
	// [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
	//  query that outputs a boolean stream.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition.query
	Query *string `json:"query,omitempty"`

	// The amount of time that a time series must violate the
	//  threshold to be considered failing. Currently, only values
	//  that are a multiple of a minute--e.g., 0, 60, 120, or 300
	//  seconds--are supported. If an invalid value is given, an
	//  error will be returned. When choosing a duration, it is useful to
	//  keep in mind the frequency of the underlying time series data
	//  (which may also be affected by any alignments specified in the
	//  `aggregations` field); a good duration is long enough so that a single
	//  outlier does not generate spurious alerts, but short enough that
	//  unhealthy states are detected and alerted on quickly.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition.duration
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`,
	//  or by the ratio, if `denominator_filter` and `denominator_aggregations`
	//  are specified.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition.trigger
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`

	// A condition control that determines how metric-threshold conditions
	//  are evaluated when data stops arriving.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition.evaluation_missing_data
	EvaluationMissingData *string `json:"evaluationMissingData,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition
type AlertPolicy_Condition_SQLCondition struct {
	// Required. The Log Analytics SQL query to run, as a string.  The query
	//  must conform to the required shape. Specifically, the query must not
	//  try to filter the input by time.  A filter will automatically be
	//  applied to filter the input so that the query receives all rows
	//  received since the last time the query was run.
	//
	//  For example, the following query extracts all log entries containing an
	//  HTTP request:
	//
	//      SELECT
	//        timestamp, log_name, severity, http_request, resource, labels
	//      FROM
	//        my-project.global._Default._AllLogs
	//      WHERE
	//        http_request IS NOT NULL
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.query
	Query *string `json:"query,omitempty"`

	// Schedule the query to execute every so many minutes.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.minutes
	Minutes *AlertPolicy_Condition_SQLCondition_Minutes `json:"minutes,omitempty"`

	// Schedule the query to execute every so many hours.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.hourly
	Hourly *AlertPolicy_Condition_SQLCondition_Hourly `json:"hourly,omitempty"`

	// Schedule the query to execute every so many days.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.daily
	Daily *AlertPolicy_Condition_SQLCondition_Daily `json:"daily,omitempty"`

	// Test the row count against a threshold.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.row_count_test
	RowCountTest *AlertPolicy_Condition_SQLCondition_RowCountTest `json:"rowCountTest,omitempty"`

	// Test the boolean value in the indicated column.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.boolean_test
	BooleanTest *AlertPolicy_Condition_SQLCondition_BooleanTest `json:"booleanTest,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.BooleanTest
type AlertPolicy_Condition_SQLCondition_BooleanTest struct {
	// Required. The name of the column containing the boolean value. If the
	//  value in a row is NULL, that row is ignored.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.BooleanTest.column
	Column *string `json:"column,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Daily
type AlertPolicy_Condition_SQLCondition_Daily struct {
	// Required. The number of days between runs. Must be greater than or
	//  equal to 1 day and less than or equal to 31 days.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Daily.periodicity
	Periodicity *int32 `json:"periodicity,omitempty"`

	// Optional. The time of day (in UTC) at which the query should run. If
	//  left unspecified, the server picks an arbitrary time of day and runs
	//  the query at the same time each day.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Daily.execution_time
	ExecutionTime *TimeOfDay `json:"executionTime,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Hourly
type AlertPolicy_Condition_SQLCondition_Hourly struct {
	// Required. The number of hours between runs. Must be greater than or
	//  equal to 1 hour and less than or equal to 48 hours.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Hourly.periodicity
	Periodicity *int32 `json:"periodicity,omitempty"`

	// Optional. The number of minutes after the hour (in UTC) to run the
	//  query. Must be greater than or equal to 0 minutes and less than or
	//  equal to 59 minutes.  If left unspecified, then an arbitrary offset
	//  is used.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Hourly.minute_offset
	MinuteOffset *int32 `json:"minuteOffset,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Minutes
type AlertPolicy_Condition_SQLCondition_Minutes struct {
	// Required. Number of minutes between runs. The interval must be
	//  greater than or equal to 5 minutes and less than or equal to 1440
	//  minutes.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.Minutes.periodicity
	Periodicity *int32 `json:"periodicity,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.RowCountTest
type AlertPolicy_Condition_SQLCondition_RowCountTest struct {
	// Required. The comparison to apply between the number of rows returned
	//  by the query and the threshold.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.RowCountTest.comparison
	Comparison *string `json:"comparison,omitempty"`

	// Required. The value against which to compare the row count.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.SqlCondition.RowCountTest.threshold
	Threshold *int64 `json:"threshold,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.Trigger
type AlertPolicy_Condition_Trigger struct {
	// The absolute number of time series that must fail
	//  the predicate for the condition to be triggered.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.Trigger.count
	Count *int32 `json:"count,omitempty"`

	// The percentage of time series that must fail the
	//  predicate for the condition to be triggered.
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Condition.Trigger.percent
	Percent *float64 `json:"percent,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Documentation.Link
type AlertPolicy_Documentation_Link struct {
	// A short display name for the link. The display name must not be empty
	//  or exceed 63 characters. Example: "playbook".
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Documentation.Link.display_name
	DisplayName *string `json:"displayName,omitempty"`

	// The url of a webpage.
	//  A url can be templatized by using variables
	//  in the path or the query parameters. The total length of a URL should
	//  not exceed 2083 characters before and after variable expansion.
	//  Example: "https://my_domain.com/playbook?name=${resource.name}"
	// +kcc:proto:field=google.monitoring.v3.AlertPolicy.Documentation.Link.url
	URL *string `json:"url,omitempty"`
}

// +kcc:proto=google.monitoring.v3.MutationRecord
type MutationRecord struct {
	// When the change occurred.
	// +kcc:proto:field=google.monitoring.v3.MutationRecord.mutate_time
	MutateTime *string `json:"mutateTime,omitempty"`

	// The email address of the user making the change.
	// +kcc:proto:field=google.monitoring.v3.MutationRecord.mutated_by
	MutatedBy *string `json:"mutatedBy,omitempty"`
}

// +kcc:proto=google.protobuf.Any
type Any struct {
	// A URL/resource name that uniquely identifies the type of the serialized
	//  protocol buffer message. This string must contain at least
	//  one "/" character. The last segment of the URL's path must represent
	//  the fully qualified name of the type (as in
	//  `path/google.protobuf.Duration`). The name should be in a canonical form
	//  (e.g., leading "." is not accepted).
	//
	//  In practice, teams usually precompile into the binary all types that they
	//  expect it to use in the context of Any. However, for URLs which use the
	//  scheme `http`, `https`, or no scheme, one can optionally set up a type
	//  server that maps type URLs to message definitions as follows:
	//
	//  * If no scheme is provided, `https` is assumed.
	//  * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	//    value in binary format, or produce an error.
	//  * Applications are allowed to cache lookup results based on the
	//    URL, or have them precompiled into a binary to avoid any
	//    lookup. Therefore, binary compatibility needs to be preserved
	//    on changes to types. (Use versioned type names to manage
	//    breaking changes.)
	//
	//  Note: this functionality is not currently available in the official
	//  protobuf release, and it is not used for type URLs beginning with
	//  type.googleapis.com.
	//
	//  Schemes other than `http`, `https` (or the empty scheme) might be
	//  used with implementation specific semantics.
	// +kcc:proto:field=google.protobuf.Any.type_url
	TypeURL *string `json:"typeURL,omitempty"`

	// Must be a valid serialized protocol buffer of the above specified type.
	// +kcc:proto:field=google.protobuf.Any.value
	Value []byte `json:"value,omitempty"`
}

// +kcc:proto=google.rpc.Status
type Status struct {
	// The status code, which should be an enum value of
	//  [google.rpc.Code][google.rpc.Code].
	// +kcc:proto:field=google.rpc.Status.code
	Code *int32 `json:"code,omitempty"`

	// A developer-facing error message, which should be in English. Any
	//  user-facing error message should be localized and sent in the
	//  [google.rpc.Status.details][google.rpc.Status.details] field, or localized
	//  by the client.
	// +kcc:proto:field=google.rpc.Status.message
	Message *string `json:"message,omitempty"`

	// A list of messages that carry the error details.  There is a common set of
	//  message types for APIs to use.
	// +kcc:proto:field=google.rpc.Status.details
	Details []Any `json:"details,omitempty"`
}

// +kcc:proto=google.type.TimeOfDay
type TimeOfDay struct {
	// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
	//  to allow the value "24:00:00" for scenarios like business closing time.
	// +kcc:proto:field=google.type.TimeOfDay.hours
	Hours *int32 `json:"hours,omitempty"`

	// Minutes of hour of day. Must be from 0 to 59.
	// +kcc:proto:field=google.type.TimeOfDay.minutes
	Minutes *int32 `json:"minutes,omitempty"`

	// Seconds of minutes of the time. Must normally be from 0 to 59. An API may
	//  allow the value 60 if it allows leap-seconds.
	// +kcc:proto:field=google.type.TimeOfDay.seconds
	Seconds *int32 `json:"seconds,omitempty"`

	// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
	// +kcc:proto:field=google.type.TimeOfDay.nanos
	Nanos *int32 `json:"nanos,omitempty"`
}
